package main

import (
	"log"
	"os"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

var db *sqlx.DB

// Event - encapsulates information about an event
type Event struct {
	ID        int       `json:"id"`
	Title     string    `json:"title"`
	Location  string    `json:"location"`
	Image     string    `json:"image"`
	Date      time.Time `json:"date"`
	Attending []string  `json:"attending"`
}

// getEventByID - returns the event that has the
// specified id and an error if there was a database err.
func getEventByID(id int) (Event, error) {
	var e Event
	query := `SELECT id,title,location,image,date FROM events WHERE id=$1`
	row := db.QueryRow(query, id)
	err := row.Scan(&e.ID, &e.Title, &e.Location, &e.Image, &e.Date)
	return e, err
}

// getAllEvents - returns a slice of all events and an
// error in case of database error.
func getAllEvents() ([]Event, error) {
	var events []Event
	query := `SELECT id,title,location,image,date FROM events`
	rows, err := db.Query(query)
	if err != nil {
		return events, err
	}
	defer rows.Close()
	for rows.Next() {
		var e Event
		err := rows.Scan(&e.ID, &e.Title, &e.Location, &e.Image, &e.Date)
		if err != nil {
			return events, err
		}
		events = append(events, e)
	}
	return events, nil
}

func addEvent(event Event) (int, error) {
	insertStatement := `
		INSERT INTO events (title, location, image, date)
		VALUES ($1, $2, $3, $4)
		RETURNING id;
	`
	// Use the global db object
	newID := 0
	err := db.QueryRow(insertStatement, event.Title, event.Location, event.Image, event.Date).Scan(&newID)
	return newID, err
}

// init is run once when this file is first loaded. See
// https://golang.org/doc/effective_go.html#init
// https://medium.com/golangspec/init-functions-in-go-eac191b3860a
func init() {
	databaseURL, ok := os.LookupEnv("DATABASE_URL")
	if !ok {
		// e.g.: YourUserName:YourPassword@YourHost:5432/YourDatabase
		panic("You must supply the DATABASE_URL")
	}
	var dbErr error

	// I suggest you use sqlx instead of golang's built-in sql
	// library. sqlx does not add much, but what it does add
	// is useful. See https://jmoiron.github.io/sqlx/
	db, dbErr = sqlx.Open("postgres", databaseURL)
	if dbErr != nil {
		panic("Could not connect to database")
	}

	makeSchema := `
		CREATE TABLE IF NOT EXISTS events (
			id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			title TEXT NOT NULL
				CHECK (char_length(title) < 51),
			location TEXT NOT NULL
				CHECK (char_length(location) < 51),
			image TEXT NOT NULL
				CHECK (image ~ '^https?://' AND image ~ '\.(png|jpg|jpeg|gif|gifv)$'),
			date TIMESTAMP WITHOUT TIME ZONE NOT NULL
		);
		-- "Upsert" our default events. This will overwrite your
		-- default events every time this code is run.
		INSERT INTO events (id, date, image, title, location) VALUES
		('1', '2019-10-17 16:30:00', 'http://i.imgur.com/pXjrQ.gif', 'SOM House Party', 'Kyle''s house'),
 		('3', '2019-10-19 19:00:00', 'http://i.imgur.com/7pe2k.gif', 'BBQ party for hackers and nerds', 'Sharon Oster''s house'),
 		('4', '2019-12-02 18:00:00', 'http://i.imgur.com/CJLrRqh.gif', 'BBQ for managers', 'Barry Nalebuff''s house'),
		('5', '2019-12-21 19:00:00', 'http://i.imgur.com/02KT9.gif', 'Cooking lessons for the busy business student', 'Yale Farm')
		ON CONFLICT ON CONSTRAINT events_pkey DO UPDATE
		SET (id, date, image, title, location) = (EXCLUDED.id, EXCLUDED.date, EXCLUDED.image, EXCLUDED.title, EXCLUDED.location) ;
	`
	_, err := db.Exec(makeSchema)
	if err != nil {
		log.Panicln("Could not create database schema:", err)
	}
}
